TrimSample : Sample {

var <> trimStart;
var <> anchorPoint; // fraction between 0 and 1
var <> grid; // eg 8*16


// CREATING & INITIALIZING =========


*new { arg  aName, aWavName;
			var me = super.new;
		     me.name_(aName.asSymbol);
		     me.wavName_ (aWavName);
			^ me.init}

init {
		this.createBuffer;
		this.parentName_ ("unknown");
		this.name.postln;
	  //  "Creating buffer for single sample- Wait before warming up".postln

	}


serverSideGridPulse{ arg myBuffer;
		// I am an ingredient for the synthDef
		// that will act as a clock pulse on the serverside
		^ Impulse.kr((myBuffer.sampleRate/myBuffer.numFrames)*this.grid)
	}

	// Impulse.ar ( 8 ).inspect
	// { Impulse.ar(80, 0.0, 0.5, 0) }.play

serverSideTriggerPointPulse{ arg myBuffer;
		// I am an ingredient for the synthDef
		// that will act as a clock pulse on the serverside
		^ Impulse.kr((myBuffer.sampleRate/myBuffer.numFrames)*this.grid)
	}



// ========== PLAYING ===================
play {   this.group.isNil.if(
		          {synth = Synth(this.name)},   // creates & stores a synth instnce
			      {synth = Synth.after(this.group,  this.name) });

		   synth.set(\outputBus, this.outBus);
		// this.outBus.debug("In sample");
	this.name.debug("CREATE synth" +  "node ID" + synth.asNodeID.asString + "with parent" + this.parentName);

		     synth.set(\loop, this.loopStatus);}
	                                                               //starts playing as soon as created


	//neither of these stops below look adequate for diff sample types
	// oh - maybe wrappers do it.... YES!!


/*
	a= SampleBank.at(\drums).buffer;
b= SampleBank.at(\vox).buffer;
c= SampleBank.at(\bass).buffer;
d= SampleBank.at(\bvs).buffer;

{
	arg now;
	var griddrums = 8 * 16;
	var gridvox = 8 * 8;
	var gridbv = 8 * 2;
	var gridbass = 8 * 1;

	var pulsedrums = Impulse.kr((a.sampleRate/a.numFrames)*griddrums); // isochronous clicks as serverside clock signals
	var pulsevox = Impulse.kr((b.sampleRate/b.numFrames)*gridvox);
	var pulsebv = Impulse.kr((d.sampleRate/d.numFrames)*gridbv);
	var pulsebass = Impulse.kr((c.sampleRate/c.numFrames)*gridbass);

	var anchordrums = TRand.kr(0, griddrums-1, pulsedrums).round(1);  //generates random float in given  range with each triggering click from  pulse
	var anchorbass = TRand.kr(0, gridbass-1, pulsebass).round(1);
	var anchorvox = TRand.kr(0, gridvox-1, pulsevox).round(1);
	var anchorbv = TRand.kr(0, gridbv-1, pulsebv).round(1);

	var drums1 = PlayBuf.ar(2, a.bufnum, BufRateScale.kr(a.bufnum), pulsedrums, (a.numFrames/griddrums)*anchordrums, 0, doneAction:0)*0.6;
	var drums2 = PlayBuf.ar(2, a.bufnum, BufRateScale.kr(a.bufnum), now, 0, 1, doneAction:0); // loops
	var bass = PlayBuf.ar(2, c.bufnum, BufRateScale.kr(c.bufnum), pulsebass, (c.numFrames/gridbass)*anchorbass, 1, doneAction:0)*0.7; //loops
	var vox = PlayBuf.ar(2, b.bufnum, BufRateScale.kr(b.bufnum), pulsevox, (b.numFrames/gridvox)*anchorvox, 0, doneAction:0)*0.6;
	var bv = PlayBuf.ar(2, d.bufnum, BufRateScale.kr(d.bufnum), pulsebv, (d.numFrames/gridbv)*anchorbv, 0, doneAction:0)*0.4;


	//PLaybuf has built in provision for a  A trigger that causes a jump to the startPos.
	// (A trigger occurs when a signal changes from negative value to positive value.)
	// startposes are chpsen by anchors which are just random grid points generated by same trigger

bass+bv+drums2


}.play
)
	*/


createSynthDef {
		   	SynthDef(this.name , {arg loop=0, volume=0.5, outputBus=0;
			Out.ar(outputBus,
				     PlayBuf.ar(2, this.buffer.bufnum,
					                     BufRateScale.kr(this.buffer.bufnum),
					                     this.serverSideGridPulse(this.buffer),
					                     this.anchorPoint,
					                        loop:loop, doneAction:2)*volume )
			                                       // WAS done action 2
			}).add;
		           // PlayBuf audio rate,  stereo,  bufferNumber., bufferRatescale .
		           // trigger, startPos
		           // we retrigger every??? how often?

		        }



	createBuffer{  //  NB audio folder assumed to be in extension folder
		 var classFilePath;
		 var directoryPath ;
		 var wavFilePath;
		var wavFilePathString;
		 var fullWavPath;
		classFilePath = PathName.new(this.class.filenameSymbol.asString);
		//classFilePath.postln;
		directoryPath = classFilePath.pathOnly;
		//directoryPath.postln;
		wavFilePathString ="audio/" ++ this.wavName ++".wav";
		//wavFilePathString.postln;
		wavFilePath =  PathName(wavFilePathString);
		//wavFilePath.postln;
		fullWavPath = directoryPath +/+  wavFilePath;
		//fullWavPath.postln;
		this.buffer_(Buffer.read(Server.default, fullWavPath.fullPath.asString));
		// this.buffer.postln;
               }



}